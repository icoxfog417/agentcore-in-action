AWSTemplateFormatVersion: '2010-09-09'
Description: MCP Server with OAuth Gateway - Infrastructure Stack

Parameters:
  StackName:
    Type: String
    Default: mcp-oauth-gateway
  GoogleClientId:
    Type: String
    NoEcho: true
  GoogleClientSecret:
    Type: String
    NoEcho: true

Resources:
  # =============================================================================
  # Outbound OAuth Callback Infrastructure (CloudFront -> Lambda -> DynamoDB)
  # Replaces local server for production-ready session binding
  # =============================================================================

  # DynamoDB table for OAuth session storage
  OAuthSessionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${StackName}-oauth-sessions'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: session_id
          AttributeType: S
      KeySchema:
        - AttributeName: session_id
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

  # Lambda execution role
  CallbackLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackName}-callback-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: dynamodb-access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt OAuthSessionTable.Arn
        - PolicyName: agentcore-access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:CompleteResourceTokenAuth
                Resource: '*'

  # Lambda function for OAuth callback - completes session binding
  CallbackLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${StackName}-oauth-callback'
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt CallbackLambdaRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_NAME: !Ref OAuthSessionTable
      Code:
        ZipFile: |
          import os
          import boto3

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])
          agentcore = boto3.client('bedrock-agentcore')

          def handler(event, context):
              qs = event.get('queryStringParameters') or {}
              session_id = qs.get('session_id')

              if not session_id:
                  return {'statusCode': 400, 'headers': {'Content-Type': 'text/html'},
                          'body': '<h1>Error</h1><p>Missing session_id</p>'}

              # Get user_id from DynamoDB (keyed by session_id)
              resp = table.get_item(Key={'session_id': session_id})
              if 'Item' not in resp:
                  return {'statusCode': 400, 'headers': {'Content-Type': 'text/html'},
                          'body': f'<h1>Error</h1><p>Unknown session: {session_id[:50]}...</p>'}

              user_id = resp['Item'].get('user_id')
              if not user_id:
                  return {'statusCode': 400, 'headers': {'Content-Type': 'text/html'},
                          'body': '<h1>Error</h1><p>Missing user_id</p>'}

              # Complete session binding with userId
              try:
                  agentcore.complete_resource_token_auth(
                      sessionUri=session_id,
                      userIdentifier={'userId': user_id}
                  )
              except Exception as e:
                  table.update_item(
                      Key={'session_id': session_id},
                      UpdateExpression='SET #s = :s, #e = :e',
                      ExpressionAttributeNames={'#s': 'status', '#e': 'error'},
                      ExpressionAttributeValues={':s': 'FAILED', ':e': str(e)}
                  )
                  return {'statusCode': 500, 'headers': {'Content-Type': 'text/html'},
                          'body': f'<h1>Error</h1><p>{str(e)}</p>'}

              # Mark as complete
              table.update_item(
                  Key={'session_id': session_id},
                  UpdateExpression='SET #s = :s',
                  ExpressionAttributeNames={'#s': 'status'},
                  ExpressionAttributeValues={':s': 'COMPLETE'}
              )

              return {'statusCode': 200, 'headers': {'Content-Type': 'text/html'},
                      'body': '<h1>Authorization Complete!</h1><p>You can close this window.</p>'}

  # Lambda Function URL (origin for CloudFront)
  CallbackLambdaUrl:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !Ref CallbackLambda

  # OAC for Lambda - restricts access to CloudFront only
  LambdaOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${StackName}-lambda-oac'
        OriginAccessControlOriginType: lambda
        SigningBehavior: always
        SigningProtocol: sigv4

  # Permission for CloudFront to invoke Lambda via OAC
  CallbackLambdaCloudFrontPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CallbackLambda
      Action: lambda:InvokeFunctionUrl
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CallbackDistribution}'
      FunctionUrlAuthType: AWS_IAM

  # CloudFront Distribution -> Lambda Function URL (via OAC)
  # Provides WAF capability, DDoS protection, and restricts Lambda access
  CallbackDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub '${StackName} OAuth callback'
        Origins:
          - Id: LambdaOrigin
            DomainName: !Select [2, !Split ['/', !GetAtt CallbackLambdaUrl.FunctionUrl]]
            OriginAccessControlId: !Ref LambdaOAC
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
              HTTPSPort: 443
        DefaultCacheBehavior:
          TargetOriginId: LambdaOrigin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD]
          CachedMethods: [GET, HEAD]
          # Managed policies: CachingDisabled + AllViewerExceptHostHeader
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
          OriginRequestPolicyId: b689b0a8-53d0-40ab-baf2-68738e2966ac

  # =============================================================================
  # Inbound Authentication Infrastructure (Cognito with Google Federation)
  # =============================================================================

  # Cognito User Pool
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub '${StackName}-pool'
      AutoVerifiedAttributes: [email]
      UsernameAttributes: [email]

  # Cognito User Pool Domain
  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Sub '${StackName}-${AWS::AccountId}'
      UserPoolId: !Ref UserPool

  # Cognito Google Identity Provider
  GoogleIdentityProvider:
    Type: AWS::Cognito::UserPoolIdentityProvider
    Properties:
      UserPoolId: !Ref UserPool
      ProviderName: Google
      ProviderType: Google
      ProviderDetails:
        client_id: !Ref GoogleClientId
        client_secret: !Ref GoogleClientSecret
        authorize_scopes: 'openid email profile'
      AttributeMapping:
        email: email
        username: sub

  # Cognito App Client
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    DependsOn: GoogleIdentityProvider
    Properties:
      ClientName: !Sub '${StackName}-client'
      UserPoolId: !Ref UserPool
      GenerateSecret: true
      SupportedIdentityProviders: [Google, COGNITO]
      CallbackURLs:
        - !Sub 'https://bedrock-agentcore.${AWS::Region}.amazonaws.com/identities/oauth2/callback'
      LogoutURLs:
        - !Sub 'https://${CallbackDistribution.DomainName}/'
      AllowedOAuthFlows: [code]
      AllowedOAuthScopes: [openid, email, profile]
      AllowedOAuthFlowsUserPoolClient: true

  # =============================================================================
  # Gateway Execution Role
  # =============================================================================

  GatewayRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${StackName}-gateway-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: workload-identity
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT
                  - bedrock-agentcore:GetResourceOAuth2Token
                Resource: '*'
              - Effect: Allow
                Action: secretsmanager:GetSecretValue
                Resource: '*'

Outputs:
  # Outbound OAuth Callback
  OAuthCallbackUrl:
    Value: !Sub 'https://${CallbackDistribution.DomainName}/'
    Description: CloudFront URL for OAuth callback (register in Google OAuth app)
  OAuthSessionTableName:
    Value: !Ref OAuthSessionTable
    Description: DynamoDB table for OAuth session storage
  DistributionId:
    Value: !Ref CallbackDistribution

  # Inbound Authentication (Cognito)
  InboundUserPoolId:
    Value: !Ref UserPool
  InboundClientId:
    Value: !Ref UserPoolClient
  InboundDiscoveryUrl:
    Value: !Sub 'https://cognito-idp.${AWS::Region}.amazonaws.com/${UserPool}/.well-known/openid-configuration'
  InboundCognitoDomain:
    Value: !Sub '${StackName}-${AWS::AccountId}'

  # Gateway
  GatewayRoleArn:
    Value: !GetAtt GatewayRole.Arn
